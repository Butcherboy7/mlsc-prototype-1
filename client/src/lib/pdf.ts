
import jsPDF from 'jspdf';

export const extractTextFromPDF = async (file: File): Promise<string> => {
  try {
    // For now, we'll use a simple text extraction method
    // In a real implementation, you'd use pdf-parse or similar
    const text = await file.text();
    
    if (text && text.trim().length > 50) {
      return text.trim();
    }
    
    // Fallback: generate content based on filename
    const fileName = file.name.toLowerCase();
    return `Content extracted from: ${file.name}\n\nThis document contains educational material that can be analyzed and summarized using AI.`;
  } catch (error) {
    console.error('Error extracting PDF text:', error);
    return `Content from: ${file.name}\n\nUnable to extract text directly. Please try with a different PDF or check if the file is text-based.`;
  }
};

export const exportToPDF = async (content: string, filename: string = 'document.pdf', isDarkMode: boolean = false) => {
  try {
    const pdf = new jsPDF();
    
    // Enhanced color scheme for better readability
    const colors = {
      text: isDarkMode ? [240, 240, 240] as [number, number, number] : [40, 40, 40] as [number, number, number],
      header: isDarkMode ? [100, 150, 255] as [number, number, number] : [59, 130, 246] as [number, number, number],
      subheader: isDarkMode ? [120, 170, 255] as [number, number, number] : [79, 150, 266] as [number, number, number],
      background: isDarkMode ? [45, 45, 45] as [number, number, number] : [255, 255, 255] as [number, number, number],
      accent: isDarkMode ? [34, 197, 94] as [number, number, number] : [22, 163, 74] as [number, number, number],
      code: isDarkMode ? [156, 163, 175] as [number, number, number] : [75, 85, 99] as [number, number, number],
      definition: isDarkMode ? [147, 51, 234] as [number, number, number] : [124, 58, 237] as [number, number, number],
      example: isDarkMode ? [34, 197, 94] as [number, number, number] : [22, 163, 74] as [number, number, number],
      math: isDarkMode ? [59, 130, 246] as [number, number, number] : [37, 99, 235] as [number, number, number]
    };
    
    // Set background
    pdf.setFillColor(colors.background[0], colors.background[1], colors.background[2]);
    pdf.rect(0, 0, pdf.internal.pageSize.width, pdf.internal.pageSize.height, 'F');
    
    // Enhanced header with better styling
    pdf.setFontSize(22);
    pdf.setTextColor(colors.header[0], colors.header[1], colors.header[2]);
    pdf.setFont('helvetica', 'bold');
    pdf.text(filename.replace('.pdf', ''), 20, 30);
    
    // Improved branding
    pdf.setFontSize(12);
    pdf.setTextColor(colors.accent[0], colors.accent[1], colors.accent[2]);
    pdf.setFont('helvetica', 'normal');
    pdf.text('Generated by Mentora - Your AI Edu Buddy', 20, 42);
    
    // Add separator line
    pdf.setDrawColor(colors.header[0], colors.header[1], colors.header[2]);
    pdf.setLineWidth(0.5);
    pdf.line(20, 48, 190, 48);
    
    // Process and render content with enhanced formatting
    const processedContent = formatContentForEnhancedPDF(content);
    let yPosition = 60;
    
    const renderContent = (sections: any[]) => {
      sections.forEach((section) => {
        // Check if we need a new page
        if (yPosition > 260) {
          pdf.addPage();
          pdf.setFillColor(colors.background[0], colors.background[1], colors.background[2]);
          pdf.rect(0, 0, pdf.internal.pageSize.width, pdf.internal.pageSize.height, 'F');
          yPosition = 30;
        }
        
        switch (section.type) {
          case 'header1':
            pdf.setFontSize(18);
            pdf.setFont('helvetica', 'bold');
            pdf.setTextColor(colors.header[0], colors.header[1], colors.header[2]);
            pdf.text(section.content, 20, yPosition);
            yPosition += 12;
            // Add underline for headers
            pdf.setDrawColor(colors.header[0], colors.header[1], colors.header[2]);
            pdf.setLineWidth(0.3);
            pdf.line(20, yPosition - 2, 20 + pdf.getTextWidth(section.content) * 18/12, yPosition - 2);
            yPosition += 4;
            break;
            
          case 'header2':
            pdf.setFontSize(16);
            pdf.setFont('helvetica', 'bold');
            pdf.setTextColor(colors.subheader[0], colors.subheader[1], colors.subheader[2]);
            pdf.text(section.content, 20, yPosition);
            yPosition += 10;
            break;
            
          case 'header3':
            pdf.setFontSize(14);
            pdf.setFont('helvetica', 'bold');
            pdf.setTextColor(colors.subheader[0], colors.subheader[1], colors.subheader[2]);
            pdf.text(section.content, 20, yPosition);
            yPosition += 8;
            break;
            
          case 'definition':
            // Definition box with background
            const defHeight = 16;
            pdf.setFillColor(colors.definition[0] + 40, colors.definition[1] + 40, colors.definition[2] + 40);
            pdf.rect(20, yPosition - 8, 170, defHeight, 'F');
            pdf.setDrawColor(colors.definition[0], colors.definition[1], colors.definition[2]);
            pdf.setLineWidth(2);
            pdf.line(20, yPosition - 8, 20, yPosition - 8 + defHeight);
            
            pdf.setFontSize(12);
            pdf.setFont('helvetica', 'bold');
            pdf.setTextColor(colors.definition[0], colors.definition[1], colors.definition[2]);
            pdf.text(section.term + ':', 25, yPosition);
            
            pdf.setFont('helvetica', 'normal');
            pdf.setTextColor(colors.text[0], colors.text[1], colors.text[2]);
            const defLines = pdf.splitTextToSize(section.definition, 140);
            defLines.forEach((line: string, index: number) => {
              pdf.text(line, 25, yPosition + 6 + (index * 5));
            });
            yPosition += Math.max(defHeight, defLines.length * 5 + 8) + 4;
            break;
            
          case 'example':
            // Example box with green accent
            const exampleHeight = Math.max(20, section.lines.length * 5 + 8);
            pdf.setFillColor(colors.example[0] + 60, colors.example[1] + 60, colors.example[2] + 60);
            pdf.rect(25, yPosition - 6, 165, exampleHeight, 'F');
            pdf.setDrawColor(colors.example[0], colors.example[1], colors.example[2]);
            pdf.setLineWidth(2);
            pdf.line(25, yPosition - 6, 25, yPosition - 6 + exampleHeight);
            
            pdf.setFontSize(11);
            pdf.setFont('helvetica', 'bold');
            pdf.setTextColor(colors.example[0], colors.example[1], colors.example[2]);
            pdf.text('📝 Example:', 30, yPosition);
            
            pdf.setFont('helvetica', 'normal');
            pdf.setTextColor(colors.text[0], colors.text[1], colors.text[2]);
            section.lines.forEach((line: string, index: number) => {
              pdf.text(line, 30, yPosition + 6 + (index * 5));
            });
            yPosition += exampleHeight + 4;
            break;
            
          case 'analogy':
            // Analogy box with blue accent
            const analogyHeight = Math.max(20, section.lines.length * 5 + 8);
            pdf.setFillColor(colors.header[0] + 60, colors.header[1] + 60, colors.header[2] + 60);
            pdf.rect(25, yPosition - 6, 165, analogyHeight, 'F');
            pdf.setDrawColor(colors.header[0], colors.header[1], colors.header[2]);
            pdf.setLineWidth(2);
            pdf.line(25, yPosition - 6, 25, yPosition - 6 + analogyHeight);
            
            pdf.setFontSize(11);
            pdf.setFont('helvetica', 'bold');
            pdf.setTextColor(colors.header[0], colors.header[1], colors.header[2]);
            pdf.text('🌍 Real-Life Analogy:', 30, yPosition);
            
            pdf.setFont('helvetica', 'normal');
            pdf.setTextColor(colors.text[0], colors.text[1], colors.text[2]);
            section.lines.forEach((line: string, index: number) => {
              pdf.text(line, 30, yPosition + 6 + (index * 5));
            });
            yPosition += analogyHeight + 4;
            break;
            
          case 'math':
            // Math block with special formatting
            pdf.setFillColor(colors.math[0] + 50, colors.math[1] + 50, colors.math[2] + 50);
            pdf.rect(30, yPosition - 6, 160, 16, 'F');
            pdf.setDrawColor(colors.math[0], colors.math[1], colors.math[2]);
            pdf.setLineWidth(2);
            pdf.line(30, yPosition - 6, 30, yPosition + 10);
            
            pdf.setFontSize(14);
            pdf.setFont('times', 'normal');
            pdf.setTextColor(colors.math[0], colors.math[1], colors.math[2]);
            pdf.text(section.content, 35, yPosition + 2);
            yPosition += 20;
            break;
            
          case 'code':
            // Code block with monospace font
            const codeHeight = Math.max(16, section.lines.length * 4 + 8);
            pdf.setFillColor(colors.code[0] + 40, colors.code[1] + 40, colors.code[2] + 40);
            pdf.rect(25, yPosition - 6, 165, codeHeight, 'F');
            pdf.setDrawColor(colors.code[0], colors.code[1], colors.code[2]);
            pdf.setLineWidth(1);
            pdf.rect(25, yPosition - 6, 165, codeHeight);
            
            if (section.language) {
              pdf.setFontSize(9);
              pdf.setFont('helvetica', 'bold');
              pdf.setTextColor(colors.code[0], colors.code[1], colors.code[2]);
              pdf.text(section.language.toUpperCase(), 30, yPosition - 2);
            }
            
            pdf.setFontSize(10);
            pdf.setFont('courier', 'normal');
            pdf.setTextColor(colors.text[0], colors.text[1], colors.text[2]);
            section.lines.forEach((line: string, index: number) => {
              pdf.text(line, 30, yPosition + 4 + (index * 4));
            });
            yPosition += codeHeight + 6;
            break;
            
          case 'bullet':
            pdf.setFontSize(12);
            pdf.setFont('helvetica', 'normal');
            pdf.setTextColor(colors.accent[0], colors.accent[1], colors.accent[2]);
            pdf.text('•', 25, yPosition);
            pdf.setTextColor(colors.text[0], colors.text[1], colors.text[2]);
            const bulletLines = pdf.splitTextToSize(section.content, 160);
            bulletLines.forEach((line: string, index: number) => {
              pdf.text(line, 32, yPosition + (index * 5));
            });
            yPosition += Math.max(6, bulletLines.length * 5) + 2;
            break;
            
          case 'numbered':
            pdf.setFontSize(12);
            pdf.setFont('helvetica', 'bold');
            pdf.setTextColor(colors.accent[0], colors.accent[1], colors.accent[2]);
            pdf.text(`${section.number}.`, 25, yPosition);
            pdf.setFont('helvetica', 'normal');
            pdf.setTextColor(colors.text[0], colors.text[1], colors.text[2]);
            const numberedLines = pdf.splitTextToSize(section.content, 155);
            numberedLines.forEach((line: string, index: number) => {
              pdf.text(line, 35, yPosition + (index * 5));
            });
            yPosition += Math.max(6, numberedLines.length * 5) + 2;
            break;
            
          case 'text':
          default:
            pdf.setFontSize(12);
            pdf.setFont('helvetica', 'normal');
            pdf.setTextColor(colors.text[0], colors.text[1], colors.text[2]);
            const lines = pdf.splitTextToSize(section.content, 170);
            lines.forEach((line: string) => {
              if (yPosition > 270) {
                pdf.addPage();
                pdf.setFillColor(colors.background[0], colors.background[1], colors.background[2]);
                pdf.rect(0, 0, pdf.internal.pageSize.width, pdf.internal.pageSize.height, 'F');
                yPosition = 30;
              }
              pdf.text(line, 20, yPosition);
              yPosition += 6;
            });
            yPosition += 2;
            break;
        }
      });
    };
    
    renderContent(processedContent);
    
    // Enhanced footer
    pdf.setFontSize(9);
    pdf.setTextColor(colors.code[0], colors.code[1], colors.code[2]);
    pdf.text('Generated by Mentora - Your AI Edu Buddy', 20, pdf.internal.pageSize.height - 15);
    
    pdf.save(filename);
  } catch (error) {
    console.error('Error exporting PDF:', error);
    // Fallback: download as text file
    const blob = new Blob([content], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename.replace('.pdf', '.txt');
    a.click();
    URL.revokeObjectURL(url);
  }
};

const formatContentForEnhancedPDF = (content: string): any[] => {
  const sections: any[] = [];
  const lines = content.split('\n');
  let currentCodeBlock: string[] = [];
  let currentLanguage = '';
  let inCodeBlock = false;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    
    // Handle code blocks
    if (line.startsWith('```')) {
      if (inCodeBlock) {
        // End code block
        sections.push({
          type: 'code',
          language: currentLanguage,
          lines: currentCodeBlock
        });
        currentCodeBlock = [];
        currentLanguage = '';
        inCodeBlock = false;
      } else {
        // Start code block
        currentLanguage = line.substring(3).trim();
        inCodeBlock = true;
      }
      continue;
    }
    
    if (inCodeBlock) {
      currentCodeBlock.push(line);
      continue;
    }
    
    // Handle headers
    if (line.startsWith('### ')) {
      sections.push({ type: 'header3', content: line.substring(4) });
    } else if (line.startsWith('## ')) {
      sections.push({ type: 'header2', content: line.substring(3) });
    } else if (line.startsWith('# ')) {
      sections.push({ type: 'header1', content: line.substring(2) });
    }
    // Handle math blocks
    else if (line.includes('$$') && line.indexOf('$$') !== line.lastIndexOf('$$')) {
      const mathContent = line.substring(line.indexOf('$$') + 2, line.lastIndexOf('$$'));
      sections.push({ type: 'math', content: mathContent });
    }
    // Handle definitions (term: definition format)
    else if (line.includes(':') && line.split(':').length === 2 && !line.startsWith('http')) {
      const [term, definition] = line.split(':').map(s => s.trim());
      if (term.length < 50 && definition.length > 0) {
        sections.push({ type: 'definition', term, definition });
      } else {
        sections.push({ type: 'text', content: line });
      }
    }
    // Handle examples
    else if (line.toLowerCase().startsWith('example:') || line.toLowerCase().includes('📝 example:')) {
      const exampleContent = line.replace(/^.*?example:\s*/i, '');
      const exampleLines = [exampleContent];
      
      // Look ahead for continuation lines
      let j = i + 1;
      while (j < lines.length && lines[j].trim() && !lines[j].trim().match(/^(#{1,3}\s|[-*•]\s|\d+\.\s|```)/)) {
        exampleLines.push(lines[j].trim());
        j++;
      }
      i = j - 1; // Skip processed lines
      
      sections.push({ type: 'example', lines: exampleLines });
    }
    // Handle analogies
    else if (line.toLowerCase().includes('real-life analogy:') || line.toLowerCase().includes('🌍 real-life analogy:')) {
      const analogyContent = line.replace(/^.*?real-life analogy:\s*/i, '');
      const analogyLines = [analogyContent];
      
      // Look ahead for continuation lines
      let j = i + 1;
      while (j < lines.length && lines[j].trim() && !lines[j].trim().match(/^(#{1,3}\s|[-*•]\s|\d+\.\s|```)/)) {
        analogyLines.push(lines[j].trim());
        j++;
      }
      i = j - 1; // Skip processed lines
      
      sections.push({ type: 'analogy', lines: analogyLines });
    }
    // Handle bullet points
    else if (line.match(/^[-*•]\s+(.+)/)) {
      const content = line.replace(/^[-*•]\s+/, '');
      sections.push({ type: 'bullet', content });
    }
    // Handle numbered lists
    else if (line.match(/^(\d+)\.\s+(.+)/)) {
      const match = line.match(/^(\d+)\.\s+(.+)/);
      if (match) {
        sections.push({ type: 'numbered', number: match[1], content: match[2] });
      }
    }
    // Handle regular text
    else if (line.length > 0) {
      // Process bold text and inline math
      let processedLine = line;
      processedLine = processedLine.replace(/\*\*([^*]+)\*\*/g, '$1'); // Remove bold markers for PDF
      processedLine = processedLine.replace(/\$([^$]+)\$/g, '[$1]'); // Convert inline math
      
      sections.push({ type: 'text', content: processedLine });
    }
  }
  
  return sections;
};
